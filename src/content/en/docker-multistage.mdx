---
title: "Get started with Docker multistage & distroless"
description: "Docker image size too big? Multistage build and Distroless base image can help you reduce the overall image size!"
image: "/src/assets/blog/docker-multistage/cover.png"
ogImage: "/opengraph/images/blog/docker-multistage.png"
tags:
  ["docker", "linux", "container", "server", "multistage", "ci/cd"]
sorting: 3
publishDate: "2025-04-01T20:30:00.000Z"
modifiedDate: "2025-04-01T20:30:00.000Z"
---

Imagine you finally finished your project, and you want to pack it into a beautiful Docker image.

You wrote a `Dockerfile`, ran the `docker build` command, 1 minute passed. After the image is built, you realized that image is **huge**. It's probably taking up 1GB for a simple Node.js application.

You probably going to ask: "Is there a way to reduce the image size?"

## The old school way: single-stage builds

Back in the old days when Docker was first introduced, we only have single-stage builds. It's simple and straightforward. You write a `Dockerfile`, and you build the image.

Here's an example of a single-stage build that builds a C++ application:

```dockerfile
FROM debian:12

COPY . /app
RUN apt-get update && apt-get install -y build-essential && \
  gcc -o /app/donut /app/donut.c

ENTRYPOINT ["/app/donut"]
```

And we are using this `donut.c` as example C program:

```c
           i,j,k,x,y,o,N;
        main(){float z[1760],a
      #define R(t,x,y) f=x;x-=t*y\
   ;y+=t*f;f=(3-x*x-y*y)/2;x*=f;y*=f;
  =0,e=1,c=1,d=0,f,g,h,G,H,A,t,D;char
 b[1760];for(;;){memset(b,32,1760);g=0,
h=1;memset(z,0,7040);for(j=0;j<90;j++){
G=0,H=1;for(i=0;i<314;i++){A=h+2,D=1/(G*
A*a+g*e+5);t=G*A        *e-g*a;x=40+30*D
*(H*A*d-t*c);y=          12+15*D*(H*A*c+
t*d);o=x+80*y;N          =8*((g*a-G*h*e)
*d-G*h*a-g*e-H*h        *c);if(22>y&&y>
 0&&x>0&&80>x&&D>z[o]){z[o]=D;b[o]=(N>0
  ?N:0)[".,-~:;=!*#$@"];}R(.02,H,G);}R(
  .07,h,g);}for(k=0;1761>k;k++)putchar
   (k%80?b[k]:10);R(.04,e,a);R(.02,d,
    c);usleep(15000);printf('\n'+(
      " donut.c! \x1b[23A"));}}
        /*3D-spinning-donut */
```

> Reference: https://github.com/limiteci/donut.c/blob/main/donut.c

It looks simple, isn't it? This image install `build-essential` package which includes almost every compiler you need to build a C++ application. Then it copies the source code, compiles it, and runs the compiled binary.

But there's a problem. `build-essential` isn't required to run the `/app/donut` binary. It's only needed during the build process. So, we are **shipping unnecessary dependencies** in the final image.

### Removing unnecessary dependencies

To solve this problem, we need to remove the unnecessary dependencies after the build process. Here's how you can do it:

```dockerfile
FROM debian:12

COPY . /app
RUN apt-get update && apt-get install -y build-essential && \
  gcc -o /app/donut /app/donut.c && \
# [!code ++]
  apt remove -y build-essential && apt autoremove -y && apt-get clean

ENTRYPOINT ["/app/donut"]
```

In above example, we removed `build-essential` package after the build process and apt cache to reduce the image size.

### Using Alpine Linux

There is another choice is to use Alpine Linux as the base image. Alpine Linux is designed to be lightweight and secure. It's only 5MB in size (when +busybox), which is much smaller than Debian.

Here's how you can convert the above Dockerfile to use Alpine Linux:

```dockerfile
FROM alpine:3

COPY . /app
RUN apk add --no-cache build-base && \
  gcc -o /app/donut /app/donut.c && \
  apk del build-base

ENTRYPOINT ["/app/donut"]
```

The result image should be much smaller than the Debian image.

But, here's the catch again: Alpine Linux uses `musl` as the standard C library, which is different from `glibc` used in most Linux distributions. It may cause compatibility issues with some C/C++ applications.

Speifically, if you got a built binary from external source that depends on `glibc`, good luck with that.

## The new way: multistage builds

Then Docker introduced multistage builds in version 17.05. It allows you to build your application in multiple stages, and copy the artifacts from one stage to another.

We can think it in this way: We can have a big kitchen full of tools and ingredients to cook a meal, but we only need a small box to serve a meal.

Here's how you can convert the above Dockerfile to use multistage builds:

```dockerfile
FROM debian:12 AS builder

RUN apt-get update && apt-get install -y build-essential

COPY . /app
RUN gcc -o /app/donut /app/donut.c

FROM debian:12

COPY --from=builder /app/donut /app/donut

ENTRYPOINT ["/app/donut"]
```

What this Dockerfile does is it builds the application in the first stage, and then copies the compiled binary to the second stage. The second stage is started from scratch and should be smaller than the first stage because it doesn't have `build-essential` package.

### Using distroless images

If you managed to try the example above, you may notice that the final image is still quite big. Since we only removed `build-essentail` that we installed additionally, the base image size is still big.

In 2017, Google introduced `distroless` images, which are minimal images that contain only the necessary libraries to run the application. The image only contains dependencies that are required to run the application, nothing more. Purer than pure.

Since distroless images don't have package manager, you can't install additional packages in the image. You can only copy the artifacts from the previous stage. This is the point where multistage is a important part of distroless images.

---

To _cook_ a distroless image, we need to use `debian:12` to build binary first, and then copy the binary to `gcr.io/distroless/static-debian12` image:

```dockerfile
FROM debian:12 AS builder

RUN apt-get update && apt-get install -y build-essential

COPY . /app
RUN gcc -static -o /app/donut /app/donut.c

FROM gcr.io/distroless/static-debian12

COPY --from=builder /app/donut /app/donut

ENTRYPOINT ["/app/donut"]
```

> Note that we added a `-static` to `gcc` here, if you don't add it, the binary will be dynamically linked and it will require `glibc` to run. (TL;DR, results larger image size)
>
> Or you can use `gcr.io/distroless/base-debian12` image

The final image should be much smaller than the previous Debian based image or Alpine based image. Since it's just a "donut" binary and nothing more.

## Final comparison

| Base image                            |  Size  |
| ------------------------------------- | :----: |
| Distroless + multistage               | 2.76MB |
| Alpine                                | 7.4MB  |
| Debian with multistage                | 117MB  |
| Debian with `build-essential` removed | 140MB  |
| Debian with `build-essential`         | 534MB  |

> Real size may vary, the above size is just an example. Image is built on my laptop with Docker `28.0.1`

As the data shown above, distroless + multistage got the smallest image size. Alpine ranked second, and Debian with multistage build process ranked third. The last two is Debian with single stage build process.

Though in this comparison, alpine is not the smallest one, but it's still a good choice considering it only got around 7MB in size.

## Conclusion

So what should you choose? Distroless or Alpine or Debian as base?

My suggestion is, use alpine if you depends on special runtime that provides prebuilt Alpine docker base image.

Use Distroless if your runtime is already prebuilt by Google. Currently, Distrobox got `python3`, `java-{17, 21}` and `nodejs-{18, 20, 22}`. These images includes these runtime that's _probably_ optimized for Distroless base image.

> [Check avaliable images here on Distroless GitHub readme](http://github.com/GoogleContainerTools/distroless?tab=readme-ov-file#what-images-are-available)

What about Debian? Unless you have a very special use case, avoid using it as base.
